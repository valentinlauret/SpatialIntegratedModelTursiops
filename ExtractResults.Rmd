---
title: "Results of Distance Sampling and Spatial Capture Recapture Integration"
author: "Valentin Lauret"
date: "`r format(Sys.time(), '%d / %m / %Y')`"
fontsize: 11pt
geometry: margin=0.5in
output: 
  bookdown::pdf_document2: 
   extra_dependencies: ["float","cuted","caption","adjustbox"]
   latex_engine: xelatex
  bookdown::word_document2:
documentclass: article
classoption: twocolumn
always_allow_html: true
mainfont: IBMPlexSerif
sansfont: IBMPlexSans
colorlinks: true
link-citations: true
toc: false
---

```{r include=FALSE}
library(mcmcplots)
library(coda)
library(tidyverse)
library(kableExtra)
library(here)
load("sea.grid.Rdata")
load("pays.rdata")

knitr::opts_chunk$set(dpi = 300, 
                      cache = TRUE, fig.height=4, 
                      fig.align='center', out.width = "90%",cache.lazy = FALSE,
                      message=FALSE, warning=FALSE)
```

# Distance Sampling 

Load results without plotting the posterior distribution.
```{r message=FALSE, warning=FALSE, include=FALSE}
load("Work/ResultatsCluster/DS_sig0res.Rdata")
# load("~/Google Drive/GITHUB/Spatial-abundance-tursiops/DS/DSfull.Rdata")
denplot(samples[,c("sigma","EN")])
outputDS <- summary(samples)
```


```{r eval=FALSE, fig.cap="Posterior distributions for DS model", include=FALSE, out.width="50%"}
mcmcplots::denplot(samples)
traplot(samples)
```

```{r eval=FALSE}
print(outputDS)
```

Abundance of bottlenose dolphins estimated via the point process.

```{r echo=FALSE}
dataDS <- function(){
  
  # load DS datasets
  load("SIPM/DS2.Rdata")
  load("sea.grid.rdata")
  
  g2 <- sea
  
  #---- DS datasets ----
  
  dim(sites) # "sites" includes the coordinates of 1335 sampled sites with associated covariates
  dim(indiv) # "indiv" includes the locations of 129 dolphins detection with associated covariates
  
  # create variables for DS
  sitesDS <- sites[]
  nsitesDS <- nrow(sites) # nb of sampled sites : 1335
  nobs <- nrow(indiv) # nb of detections : 129  
  
  site <- indiv$DSid #   site id of every detection
  
  gDS <- g2 %>% mutate(DSid = 1:nrow(g2))  # sampled sites by aerial surveys 
  
  sampDS <- rep(NA, nrow(sites))
  for(i in 1:nrow(sites)){
    index <-  sites$objectid[i]
    sampDS[i] <-  which(g2$objectid == index)
  }
  
  # format detection data with 10 Bins
  d <- indiv$d_perp / max(indiv$d_perp) # perpendicular distance to the transect
  B <- max(d) # max distance
  delta <- 0.1 # distance bin width: 0.1, we created 10 bins
  midpt <- seq(delta/2, B, delta) # make mid-points and chop up data
  dclass <- d %/% delta + 1 # convert distances to cat. distances
  nD <- length(midpt) # Number of distance intervals
  
  # group size format
  gp <- sites$taille_grp  # group size detected
  groupsize <- gp # Input groupsize as data
  groupsize[is.na(groupsize)] <- 0
  
  
  # sampling effort covariates 
  seffDS <- log(as.numeric(sitesDS$samm.effort)) # sampling effort covariate
  sea.stateDS <- as.numeric(scale(sitesDS$seg_subj_num)) # sea state as detection covariate
  
  # environmental covariate
  habitat <- as.numeric(g2$bathy.sc)[sampDS]
  
  # inits
  Nst <- groupsize + 1 
  Nst[is.na(Nst)] <- 0
  
  # save data
  dataDS <- list(nobs = nobs, B = B, nsitesDS = nsitesDS, midpt = midpt,
                 delta = delta, nD = nD, site = site,sampDS= sampDS,
                 seffDS = seffDS, sea.stateDS = sea.stateDS,
                 habitat = habitat,dclass= dclass,  groupsize = groupsize, Nst = Nst)
  
  return(dataDS)
}

datDS <- dataDS()
dim(samples$chain1)
ch <- rbind(samples$chain1[30000:nrow(samples$chain1),],samples$chain2[30000:nrow(samples$chain1),],samples$chain3[30000:nrow(samples$chain1),])
#ch <- samples

ch <- ch[sample(1:nrow(ch),10000),]
res1 <- matrix(NA,nrow= nrow(ch),ncol = nrow(sea$bathy.sc))

sigmads <- matrix(NA,nrow= nrow(ch),ncol = length(datDS$seffDS))
head(ch)
  mu0ds <-  mu1ds <- rep(NA, nrow(ch))
  alpha0ds <-  alpha1ds <- alpha2ds <-  rep(NA, nrow(ch))
for(i in 1:nrow(res1)){
     res1[i,] <- exp(ch[i,"mu0"]+ ch[i,"mu1"]*sea$bathy.sc)
    mu0ds[i] <- ch[i,"mu0"]
    mu1ds[i] <- ch[i,"mu1"]
    
    alpha0ds[i] <- ch[i,"alpha0"]
    alpha1ds[i] <- ch[i,"alpha1"]
    alpha2ds[i] <- ch[i,"alpha2"]
    sigmads[i,] <- exp(alpha0ds[i] + alpha1ds[i]*datDS$seffDS +  alpha2ds[i]*datDS$sea.stateDS)
}

resDS <- apply(res1,1,sum)
summary(resDS)
```

# Spatial Capture Recapture

Load results without posterior distribution

```{r include=FALSE}
# load("SCR/SCRparafull.rdata")
load("Work/ResultatsCluster/SCR_sig0res2.rdata")

# SCR
dataSCR <- function(M = double(0)){
  
  # load data 
  load("SCR/SCR5.rdata")
  
  
  y.scr <- y.scr[,samp.sites,] # subset the detection history matrix to sampled sites only
  
  
  # get UTM coordinates of sampled sites and of all sites of the study area 
  traploc <- cbind(g2$X[samp.sites],g2$Y[samp.sites])
  sites <- cbind(g2$X,g2$Y)
  
  
  # 
  ybis <- y.scr
  
  
  nsites <- nrow(sites)  # number of sites
  # full analysis will be run with nsites = 4356
  nind <- dim(ybis)[1]  # nb of ind = 927
  nocc <- dim(ybis)[3]  # nb of occ = 8
  ntrap <- dim(ybis)[2]  # nb of trap = 327 (i.e. nb of sampled sites)
  
  
  # Data Augmentation 
  M <- M
  if(M < nind) stop()
  
  
  ## DT: here's the main change we're going to make
  ## change the representation of ybis, so instead of a 3-dimensional
  ## array (individuals x traps x occasions) of 0's and 1's,
  ## instead it will be a 3-dimensional array of
  ## (individuals x occasions x trap IDs with captures)
  ## specifically: for individual i, on occasion t, ybis[i, t, 1:MAX] will contain
  ## the trap IDs of these captures (with 0's following the final capture trap ID,
  ## or all 0's if individual i was never captured on occasion t.
  ## we'll have to set the size MAX correctly, based on the maximum
  ## number of sightings of any individual
  
  MAX <- max(apply(ybis, c(1,3), sum))
  ybis2 <- array(0, c(nind, nocc, MAX))
  for(i in 1:nind) {
    for(t in 1:nocc) {
      trapIDs <- which(ybis[i,,t] > 0)
      numSightings <- length(trapIDs)
      if(numSightings > 0) ybis2[i, t, 1:numSightings] <- trapIDs
    }
  }
  
  
  ## DT: new data augmentation using ybis2
  ## augmented individuals just have all 0's in ybis2
  ## we'll call this new variable y.da2, to distinguish it
  
  y.da2 <- array(0, c(M, nocc, MAX))
  y.da2[1:nind,,] <- ybis2
  dim(y.da2)
  max(y.da2) ## must be < ntrap
  
  
  ## DT: create z initial values using y.da2
  z <- as.numeric(apply(y.da2, 1, sum) > 0)
  
  # draw starting locations from the list of sites
  # for known individual, take the mean location where they have been seen
  set.seed(32)   ## DT: moved set.seed() here
  head(sites)
  
  id <- sample(1:nsites, M, replace= TRUE)
  
  for(i in 1:nind) {
    
    if(z[i] == 1) {
      siteVector <- as.numeric(y.da2[i,,1:MAX])
      if(max(siteVector) == 0) stop()
      sitesSeen <- siteVector[which(siteVector>0)]
      id[i] <- samp.sites[median(sitesSeen)]   
      ## if an ind is seen at multiple locations, we kept oen location as the starting activity center
    }
  }
  
  # environmental covariate
  habitat <- as.numeric(g2$bathy.sc)
  
  # effort covariate log-transformed
  eff.cov <- seff[samp.sites,] %>% 
    as_tibble() %>% 
    select(occ1, occ2,occ3,occ4, occ5, occ6, occ7, occ8) %>%
    log() %>% 
    as.matrix()
  
  eff.cov[eff.cov == - Inf] <-  0
  
  # make a binary cov with 1 if sites i is sampled during occ j, and 0 otherwise
  eff.ind <- eff.cov
  eff.ind[eff.ind!=0] <- 1
  
  
  dataSCR <- list(nsites = nsites, nind = nind, nocc = nocc, ntrap = ntrap, traploc = traploc,
                  habitat = habitat, seff = eff.cov, eff.ind = eff.ind, MAX = MAX, M = M, sites = sites, z=z,
                  y.scr = y.da2, id = id)
  
  return(dataSCR)
}
M <- 5000
datSCR <- dataSCR(M = M)

#str(samples2) # Warning : it is the result of a parallelization of 3 chains that contain each 3 chians 
ch <- samples
```

```{r eval=FALSE, include=FALSE}
traplot(samples[,c("EN","mu1","p0","p1","sigma")])
denplot(samples[,c("EN","mu1","p0","p1","sigma")])

 ch1 <- samples[1]
# 
# ch2 <- SCRp10[2]
# 
# ch3 <- SCRp10[3]
# 
# ch11 <- ch1[[1]][1]
# ch12 <- ch1[[1]][2]
# ch13 <- ch1[[1]][3]
# 
# ch21 <- ch2[[1]][1]
# ch22 <- ch2[[1]][2]
# ch23 <- ch2[[1]][3]
# 
# ch31 <- ch2[[1]][1]
# ch32 <- ch2[[1]][2]
# ch33 <- ch2[[1]][3]
# 
# denplot(c(ch11,ch12,ch21,ch22,ch31,ch32, ch13, ch23, ch33))
# traplot(c(ch11,ch12,ch21,ch22,ch31,ch32, ch13, ch23, ch33))

# SCRch <- list(as.mcmc(ch1),as.mcmc(ch2),as.mcmc(ch3))
```


```{r eval=FALSE, include=FALSE}
# outputSCR <- summary(coda::as.mcmc.list(SCRch))
# outputSCR
```

Abundance predicted via the point process $lambda$ 

```{r echo=FALSE}
load("sea.grid.rdata")

# cch <- coda::as.mcmc.list(samples2)
# dim(SCR[[1]])
# 
# # keep only last iteration when convergence is ok
# ch <- rbind(SCR[[1]],SCR[[2]],SCR[[3]])
# ch <- samples2
# head(ch)
dim(ch)

ch <- data.frame(bind_rows(as_tibble(samples$chain1), as_tibble(samples$chain2)))

#ch <- ch[10000:nrow(ch),]
res2 <- matrix(NA,nrow= nrow(ch),ncol = nrow(sea$bathy.sc))
p0scr_scr <- matrix(NA,nrow= nrow(ch),ncol = length(datSCR$seff[datSCR$seff>0]))

mu0scr <- mu1scr <- rep(NA,nrow(ch))
sigmascr <- rep(NA,nrow(ch))
p0scr <- p1scr <- rep(NA,nrow(ch))

for(i in 1:nrow(res2)){
    res2[i,] <- exp(ch[i,"mu0"]+ ch[i,"mu1"]*sea$bathy.sc)
    mu0scr[i] <- ch[i,"mu0"]
    mu1scr[i] <- ch[i,"mu1"]
    
    #beta0scr[i] <- ch[i,"beta0"]
    #beta1scr[i] <- ch[i,"beta1"]
    #sigmascr[i,] <- exp(beta0scr[i] + beta1scr[i]*datSCR$seff[datSCR$seff>0])
    
    p0scr[i] <- ch[i,"p0"]
    p1scr[i] <- ch[i,"p1"]
    
    p0scr_scr[i,] <-  exp(p0scr[i] + p1scr[i]*datSCR$seff[datSCR$seff>0])
}

resSCR <- apply(res2,1,sum)
summary(resSCR)

```

Map of the density surface $\lambda$.

```{r echo=FALSE}
load("pays.rdata")
library(cowplot)
library(ggplot2)
map2 <- ggplot()+ geom_sf(data = sea, aes(fill = matrixStats::colMedians(res2)), lwd = 0.01) + geom_sf(data = pays, lwd = 0.2) + 
  scale_fill_viridis_c(limits = c(0,max(matrixStats::colMedians(res2)))) +
  labs(title = "Spatial Capture-Recapture",fill = "Density")+ theme_cowplot(rel_large = 1, rel_tiny = 0.7)

map2
```

Map of Activity Centers

```{r echo=FALSE}
# try to plot ACs
# 3 chains MCMC
# dim(ch)
# str(samples)
 head(ch[,5000:5012])
# coda::effectiveSize(ch[,"mu1"])

ids <- round(ch[,3:5002])
zs <- ch[,5008:10007]
dim(ids)

ACi <- rep(NA,ncol(ids))
ACs <- rep(0,nrow(sea))
for(i in 1:ncol(ids)){
  ta <- table(ids[,i])
  tz <- table(zs[i])
  zz <- as.numeric(names(tz[which(tz == max(tz) )]))[1]
  if(zz == 1){
  ACi[i] <- as.numeric(names(ta[which(ta == max(ta) )]))[1]
  ACs[ACi[i]] <- ACs[ACi[i]] + 1 } # end if
}
#length(ACs)
ACSCR <- ACs
mapAC <- ggplot() +  
  geom_sf(data = sea, aes(fill= ACs),lwd = 0) + 
  #geom_sf(data = sea[datSCR$id,], fill= "red",lwd = 0) + 
  scale_fill_gradient(low = "white", high = "blue") +
  geom_sf(data= pays) + 
  labs(title = "Spatial Capture-Recapture")+ theme_cowplot(rel_large = 1, rel_tiny = 0.7)

mapAC
```

# Spatial Integrated Pop. Model

Load results without postierior distribution 

```{r include=FALSE}
load("Work/ResultatsCluster/SIM_sig0res2.rdata")
denplot(samples[,c("EN","mu1","mu0","alpha0","p0","sigma.scr","sigma.ds")])
SIPM_output <-  samples
str(SIPM_output) # 6 chains 
```


```{r echo=FALSE}
ch1 <-SIPM_output[1]         

ch2 <- SIPM_output[2]

ch3 <- SIPM_output[3]

ch11 <- ch1[[1]][1]
ch12 <- ch1[[1]][2]
#ch13 <- ch1[[1]][3]

ch21 <- ch2[[1]][1]
ch22 <- ch2[[1]][2]
#ch23 <- ch2[[1]][3]

ch31 <- ch2[[1]][1]
ch32 <- ch2[[1]][2]
#ch33 <- ch2[[1]][3]

#mcmcplots::denplot(c(ch11,ch12,ch21,ch22,ch31,ch32))
#traplot(c(ch11,ch12,ch21,ch22,ch31,ch32))
#mcmcplots::denplot(ch1[,c("beta0","beta1")])
#which(ch1[[1]][,"mu1"]<0)
#
#coda::effectiveSize(ch1[,c("mu0","mu1")])
#
#
#SIMch <- list(as.mcmc(ch11),as.mcmc(ch12),as.mcmc(ch21),as.mcmc(ch22),as.mcmc(ch31),as.mcmc(ch32))


SIMch <- list(as.mcmc(ch1),as.mcmc(ch2))#,as.mcmc(ch3))

```


Abundance predicted via the point process $\lambda$ 


```{r echo=FALSE}
#head(summary(sim1ch))


# dim(SIM[[1]])
# keep only iterations when convergence is ok
ch <- rbind(samples[[1]],samples[[2]])#,SIM[[3]])
dim(ch)
#ch <- ch[sample(1:nrow(ch),10000),]

res3 <- matrix(NA,nrow= nrow(ch),ncol = nrow(sea$bathy.sc))
poscr_sim <- sigmads_sim <- matrix(NA,nrow= nrow(ch),ncol = length(datDS$seffDS))
# head(ch)


mu0sim <- mu1sim <- rep(NA,nrow(ch))
sigmascr <- sigmads <- rep(NA,nrow(ch))
p0sim <- p1sim <- rep(NA,nrow(ch))
alpha0sim <- alpha1sim <- alpha2sim <- rep(NA,nrow(ch))

for(i in 1:nrow(res3)){
     res3[i,] <- exp(ch[i,"mu0"]+ ch[i,"mu1"]*sea$bathy.sc)
    mu0sim[i] <- ch[i,"mu0"]
    mu1sim[i] <- ch[i,"mu1"]
    
   sigmascr[i] <- ch[i,"sigma.scr"]
    sigmads[i] <- ch[i,"sigma.ds"]
    
    p0sim[i] <- ch[i,"p0"]
    p1sim[i] <- ch[i,"p1"]
    
 #   p0scr_sim[i,] <-  exp(p0sim[i] + p1sim[i]*datSCR$seff[datSCR$seff>0])
    
    alpha0sim[i] <- ch[i,"alpha0"]
    alpha1sim[i] <- ch[i,"alpha1"]
    alpha2sim[i] <- ch[i,"alpha2"]
    
    sigmads_sim[i,] <-  exp(alpha0sim[i] + alpha1sim[i]*datDS$seffDS[datDS$seffDS>0] + alpha2sim[i]*datDS$sea.stateDS[datDS$seffDS>0])
}


resSIPM <- apply(res3,1,sum)
summary(resSIPM)
```

Map of the density of bottlenose dolphins.

```{r echo=FALSE}
map3 <- ggplot()+ geom_sf(data = sea, aes(fill = matrixStats::colMedians(res3)), lwd = 0.01) + geom_sf(data = pays, lwd = 0.2) + 
  #scale_fill_viridis_c(limits = c(0,max(matrixStats::colMedians(res3)))) +
  labs(title = "Spatial Integrated Model",fill = "Density")+ theme_cowplot(rel_large = 1, rel_tiny = 0.7)

map3
```

Map of Activity Centers

```{r echo=FALSE}
# try to plot ACs
# 3 chains MCMC
dim(ch)
head(ch[,5000:5015])
head(ch[,1:10])

ids <- round(ch[,7:5006])
dim(ids)

ACi <- rep(NA,ncol(ids))
ACs <- rep(0,nrow(sea))
for(i in 1:ncol(ids)){
  ta <- table(ids[,i])
  ACi[i] <- as.numeric(names(ta[which(ta == max(ta) )]))[1]
  ACs[ACi[i]] <- ACs[ACi[i]] + 1 
}
length(ACs)
ACIM <- ACs
mapAC <- ggplot() + 
  geom_sf(data = sea, aes(fill= ACs),lwd = 0) + 
  scale_fill_gradient( low = "white", high = "red") +
  geom_sf(data= pays) + 
  labs(title = "Integrated model")+ theme_cowplot(rel_large = 1, rel_tiny = 0.7)

mapAC
```

# Comparison between DS, SCR, and integrated model

## About population size 


Posterior distributions of population size calculated as the integration of the point process: $\sum \lambda$

```{r echo=FALSE}
lambda <- dplyr::tibble(Abundance = c(resDS,resSCR, resSIPM), model = c(rep("DS",length(resDS)),
                                                                 rep("SCR",length(resSCR)),                                                                 rep("SIPM",length(resSIPM))))

violin <- ggplot(data = lambda) + geom_violin(aes(x = model,y = Abundance, fill = model)) +theme(legend.position = "none") + theme_minimal()


dens <- ggplot(data = lambda) + geom_density(aes(x = Abundance, fill = model))+theme_minimal()

#cowplot::plot_grid(violin, dens, ncol = 2, nrow = 1)
violin
```


</center>

## Models estimates 


```{r echo=FALSE}
# columns : Description / Parameter / SIM / SCR / DS
# Rows : EN / mu0 / mu2/ Intercept p / slope seff / sea.stateDS
tab <- tibble(Description = c("","","","","","","","","",""), Parameter = c("E(N)", "μ_0", "μ_1","beta0","beta1"," p0","p1","alpha0","alpha1", "alpha2"),SIM = rep(NA,10),SCR= rep(NA,10),DS = rep(NA,10))

# SIM

# EN/ mu0/mu1
tab[1:3,3] <- c(paste0(round(mean(resSIPM))," (",round(quantile(resSIPM, probs = c(0.1))), ":", round(quantile(resSIPM, probs = c(0.9))),")"),
                paste0(round(quantile(mu0sim, probs = c(0.5)),2)," (",round(quantile(mu0sim, probs = c(0.1)),2), ":", round(quantile(mu0sim, probs = c(0.9)),2),")"),
                paste0(round(quantile(mu1sim, probs = c(0.5)),2)," (",round(quantile(mu1sim, probs = c(0.1)),2), ":", round(quantile(mu1sim, probs = c(0.9)),2),")"))

# beta0/beta1
tab[4:5,3] <- c(paste0(round(mean(beta0sim),2)," (",round(quantile(beta0sim, probs = c(0.1)),2), ":", round(quantile(beta0sim, probs = c(0.9)),2),")"),
                paste0(round(mean(beta1sim),2)," (",round(quantile(beta1sim, probs = c(0.1)),2), ":", round(quantile(beta1sim, probs = c(0.9)),2),")"))

# pbar0/pbar1
tab[6:7,3] <- c(paste0(round(mean(p0sim),2)," (",round(quantile(p0sim, probs = c(0.1)),2), ":", round(quantile(p0sim, probs = c(0.9)),2),")"),
                paste0(round(mean(p1sim),2)," (",round(quantile(p1sim, probs = c(0.1)),2), ":", round(quantile(p1sim, probs = c(0.9)),2),")"))

# alpha0/alpha1/alpha2
tab[8:10,3] <- c(paste0(round(mean(alpha0sim),2)," (",round(quantile(alpha0sim, probs = c(0.1)),2), ":", round(quantile(alpha0sim, probs = c(0.9)),2),")"),
                paste0(round(mean(alpha1sim),2)," (",round(quantile(alpha1sim, probs = c(0.1)),2), ":", round(quantile(alpha1sim, probs = c(0.9)),2),")"),
                paste0(round(mean(alpha2sim),2)," (",round(quantile(alpha2sim, probs = c(0.1)),2), ":", round(quantile(alpha2sim, probs = c(0.9)),2),")"))

# SCR
tab[1:3,4] <- c(paste0(round(mean(resSCR))," (",round(quantile(resSCR, probs = c(0.1))), ":", round(quantile(resSCR, probs = c(0.9))),")"),
                paste0(round(quantile(mu0scr, probs = c(0.5)),2)," (",round(quantile(mu0scr, probs = c(0.1)),2), ":", round(quantile(mu0scr, probs = c(0.9)),2),")"),
                paste0(round(quantile(mu1scr, probs = c(0.5)),2)," (",round(quantile(mu1scr, probs = c(0.1)),2), ":", round(quantile(mu1scr, probs = c(0.9)),2),")"))

# beta0/beta1
tab[4:5,4] <- c(paste0(round(mean(beta0scr),2)," (",round(quantile(beta0scr, probs = c(0.1)),2), ":", round(quantile(beta0scr, probs = c(0.9)),2),")"),
                paste0(round(mean(beta1scr),2)," (",round(quantile(beta1scr, probs = c(0.1)),2), ":", round(quantile(beta1scr, probs = c(0.9)),2),")"))

# pbar0/pbar1
tab[6:7,4] <- c(paste0(round(mean(p0scr),2)," (",round(quantile(p0scr, probs = c(0.1)),2), ":", round(quantile(p0scr, probs = c(0.9)),2),")"),
                paste0(round(mean(p1scr),2)," (",round(quantile(p1scr, probs = c(0.1)),2), ":", round(quantile(p1scr, probs = c(0.9)),2),")"))


# DS
tab[1:3,5] <- c(paste0(round(mean(resDS))," (",round(quantile(resDS, probs = c(0.1))), ":", round(quantile(resDS, probs = c(0.9))),")"),
                paste0(round(quantile(mu0ds, probs = c(0.5)),2)," (",round(quantile(mu0ds, probs = c(0.1)),2), ":", round(quantile(mu0ds, probs = c(0.9)),2),")"),
                paste0(round(quantile(mu1ds, probs = c(0.5)),2)," (",round(quantile(mu1ds, probs = c(0.1)),2), ":", round(quantile(mu1ds, probs = c(0.9)),2),")"))

tab[8:10,5] <- c(paste0(round(mean(alpha0ds),2)," (",round(quantile(alpha0ds, probs = c(0.1)),2), ":", round(quantile(alpha0ds, probs = c(0.9)),2),")"),
                paste0(round(mean(alpha1ds),2)," (",round(quantile(alpha1ds, probs = c(0.1)),2), ":", round(quantile(alpha1ds, probs = c(0.9)),2),")"),
                paste0(round(mean(alpha2ds),2)," (",round(quantile(alpha2ds, probs = c(0.1)),2), ":", round(quantile(alpha2ds, probs = c(0.9)),2),")"))


tab
# kableExtra::kable(tab, align = "c") %>% kable_styling(font_size = 17, position = "center") %>% # column_spec(1, bold = T, color= "black") %>%  column_spec(2, color= "black") 
# 
# write_csv(tab, path = "tab.csv")

```


## Maps

Density maps are from the point process $\lambda$ derived from the estimated parameters `mu0` and `mu1`.  

```{r echo=FALSE, fig.height= 7}
library(cowplot)
library(ggtext)
library(patchwork)

map1 <- ggplot()+ geom_sf(data = sea, aes(fill = matrixStats::colMedians(res1)), lwd = 0.01) + geom_sf(data = pays, lwd = 0.2)+  
  scale_fill_gradient( limits = c(0,max(matrixStats::colMedians(res1))))+ 
   labs(title = "A. Density estimates",fill = "Density",subtitle = "*1. Distance Sampling*",
       caption = "Est. abundance: 8478 (80% CI - 7635; 9329)")+
  theme_cowplot() +
   theme(legend.position = "right", plot.title.position = 'panel', plot.subtitle = element_markdown()) 



map2 <- ggplot()+ geom_sf(data = sea, aes(fill = matrixStats::colMedians(res2)), lwd = 0.01) + geom_sf(data = pays, lwd = 0.2) + 
  scale_fill_gradient(limits = c(0,max(matrixStats::colMedians(res2)))) +
   labs(fill = "Density",subtitle = "*2. Spatial Capture Recapture*",
       caption = "Est. abundance: 1487 (80% CI - 1426; 1550)")+ 
  theme_cowplot() + 
  theme(legend.position = "right", plot.subtitle = element_markdown()) 


map3 <- ggplot()+ geom_sf(data = sea, aes(fill = matrixStats::colMedians(res3)), lwd = 0.01) + geom_sf(data = pays, lwd = 0.2)+ 
  scale_fill_gradient(limits = c(0,max(matrixStats::colMedians(res3))))+ 
  labs(fill = "Density",subtitle = "*3. Integrated model*",
       caption = "Est. abundance: 1824 (80% CI - 1761; 1888)")+ 
  theme_cowplot() +
  theme(legend.position = "right", plot.subtitle = element_markdown()) 

#fig3up <- plot_grid(map3, map2, map1, ncol = 3, nrow = 1, labels = "AUTO")#, rel_widths = c(0.8,0.8,1.1))

# difference in density between DS and SIM
DSmSIM <- ((matrixStats::colMedians(res3))-matrixStats::colMedians(res1))/(matrixStats::colMedians(res3)) 
SCRmSIM <- ((matrixStats::colMedians(res3))-matrixStats::colMedians(res2))/(matrixStats::colMedians(res3))
SCRmDS <- abs(((matrixStats::colMedians(res1))-matrixStats::colMedians(res2))/(matrixStats::colMedians(res1))) 

diffDSIM <- ggplot()+ geom_sf(data = sea, 
                              aes(fill = DSmSIM), lwd = 0.01) +
  geom_sf(data = pays, lwd = 0.2)+ 
  scale_fill_viridis_c(limits = c(min(DSmSIM,SCRmSIM), max(DSmSIM,SCRmSIM)))+ 
  labs(fill = "Density differences") + labs(title = "B. Differences between \n models", subtitle = "*1. Integrated Model - DS*")+ theme_cowplot() + theme(legend.position = "bottom", plot.title.position = "panel", plot.subtitle = element_markdown()) + 
  guides(fill = guide_colorbar(title.position = 'top', title.hjust = .5, barwidth = unit(10, 'lines'), barheight = unit(.5, 'lines')))
#diffDSIM

diffSCRIM <- ggplot()+ geom_sf(data = sea, aes(fill = SCRmSIM), lwd = 0.01) +
  geom_sf(data = pays, lwd = 0.2)+ 
  scale_fill_viridis_c(limits = c(min(DSmSIM,SCRmSIM), max(DSmSIM,SCRmSIM)))+ 
  labs(fill = "Density differences") + 
  labs(subtitle = "*2. Integrated Model - SCR*")+
  theme_cowplot() +
  theme(legend.position = "none", plot.subtitle = element_markdown())


# diffDSCR <- ggplot()+ geom_sf(data = sea,  aes(fill = SCRmDS), lwd = 0.01) +
#   geom_sf(data = pays, lwd = 0.2)+ 
#   scale_fill_viridis_c(limits = c(0, max(DSmSIM,SCRmSIM)))+ 
#   labs(fill = "Density differences") + labs(subtitle = "*DS - SCR*")+ theme_cowplot() + # theme(legend.position = "bottom", plot.title.position = "panel", plot.subtitle = element_markdown()) # + 
#   guides(fill = guide_colorbar(title.position = 'top', title.hjust = .5, barwidth = unit(10, # 'lines'), barheight = unit(.5, 'lines')))
#  

p <- (map1 / map2 / map3) | (diffDSIM   / diffSCRIM)
p
ggsave(p, file = "Fig3.png", dpi = 300, path= getwd())
```

Plot ACs

```{r}
ptSCR <- sf::st_centroid(sea) %>% 
  mutate(AC = ACSCR) %>% 
  filter(AC > 0)


pACSCR <- ggplot()+ 
 geom_sf(data = ptSCR, aes(size = AC, color = AC)) +
  geom_sf(data = pays, lwd = 0.1, alpha = 0.5 )+
  scale_size(limits = c(1,max(ACSCR, ACIM))) +
  scale_color_viridis_c( option = "D",direction = -1) +
  labs(color = "Acitivity centers") + 
  labs(subtitle = "*1. Spatial Capture Recapture*",
       size = "Number of acitivity centers",
       caption = "Est. abundance: 1487 (80% CI - 1426; 1550)")+
  theme_cowplot() +
  guides(colour = "none")+
  theme(legend.position = "top",plot.title.position = "plot", plot.subtitle = element_markdown())
pACSCR

# SIM 
ptIM <- sf::st_centroid(sea) %>% 
  mutate(AC = ACIM) %>% 
  filter(AC > 0)

pACIM <- ggplot()+ 
  geom_sf(data = ptIM, aes(size = AC, color = AC)) +
  geom_sf(data = pays, lwd = 0.1, alpha = 0.5 )+
 scale_size(limits = c(1,max(ACSCR, ACIM))) +
  scale_color_viridis_c( option = "D",direction = -1) +
  labs(color = "Acitivity centers") + 
  labs(subtitle = "*2. Integrated Model*",
       caption = "Est. abundance: 1824 (80% CI - 1761; 1888)")+
  theme_cowplot() +
  theme(legend.position = "none", plot.subtitle = element_markdown())

pACIM

pAC <- (pACSCR + pACIM)
ggsave(pAC, file = "FigAC.png", dpi = 300, path= getwd())

```


Comparaison zone par zone 

```{r echo=FALSE}
library(sf)
library(matrixStats)
load("SCR/SCR5.rdata")
dens <- g2 %>% mutate(dDS = colMeans(res1), dSCR = colMeans(res2), dSIPM = colMeans(res3), dSCRi= colQuantiles(res2, probs = 0.05),dSCRu= colQuantiles(res2, probs = 0.95))

# cote continentale fr
dens_coast <- dens %>% filter(suivi == "GDEGeM")

sum(dens_coast$dDS)
sum(dens_coast$dSCR)
sum(dens_coast$dSCRi)
sum(dens_coast$dSCRu)
#quantile(dens_coast$dSCR, probs = c(0.1,0.9))

sum(dens_coast$dSIPM)

# DS_coast <- sites  %>% st_crop(st_bbox(g2 %>% filter(suivi == "GDEGeM")))
# sum(sites$taille_grp[which(is.na(sites$taille_grp)==F)])
# sum(DS_coast$taille_grp[which(is.na(DS_coast$taille_grp)==F)])
 
# large
dens_pel <- dens %>% filter(is.na(suivi)== T)

sum(dens_pel$dDS)
sum(dens_pel$dSCR)
sum(dens_pel$dSIPM)
 
 
# all 
quantile(resDS, probs = c(0.05,0.95))

# table that display estimation of pop size for coastal & pelagic waters
# columns : Waters / DS / SCR / SIM 
# Rows : Coastal / Pelagic / Total
tab <- tibble(Waters = c("Coastal","Pelagic", "Total"), DS = c(round(sum(dens_coast$dDS)), round(sum(dens_pel$dDS)), round(mean(resDS)) ),
              SCR= c(round(sum(dens_coast$dSCR)), round(sum(dens_pel$dSCR)), round(mean(resSCR)) ),
              SIM = c(round(sum(dens_coast$dSIPM)), round(sum(dens_pel$dSIPM)), round(mean(resSIPM)) ))


tab

```

